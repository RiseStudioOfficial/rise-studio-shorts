name: Make & Upload Shorts
on:
  schedule:
    - cron: "0 7 * * *"   # 07:00 UTC ежедневно (10:00 Киев, лето)
  workflow_dispatch:

jobs:
  build-upload:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install deps
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg python3 python3-pip
          pip3 install google-api-python-client google-auth-oauthlib google-auth-httplib2

      - name: Ensure assets present (fetch if empty)
        env:
          PEXELS_API_KEY: ${{ secrets.PEXELS_API_KEY }}
          PIXABAY_API_KEY: ${{ secrets.PIXABAY_API_KEY }}
          TARGET_BG_COUNT: "120"
          TARGET_MUSIC_COUNT: "30"
        run: |
          python3 - << 'PY'
import os, glob, sys, subprocess
need_fetch=False
if len(glob.glob('assets/backgrounds/*'))<10: need_fetch=True
if len(glob.glob('assets/music/*.mp3'))<5: need_fetch=True
sys.exit(1) if need_fetch else sys.exit(0)
PY
        continue-on-error: true

      - name: Fetch assets (if needed)
        if: failure()
        env:
          PEXELS_API_KEY: ${{ secrets.PEXELS_API_KEY }}
          PIXABAY_API_KEY: ${{ secrets.PIXABAY_API_KEY }}
          TARGET_BG_COUNT: "120"
          TARGET_MUSIC_COUNT: "30"
        run: |
          pip3 install requests
          python3 scripts/fetch_assets.py
          python3 scripts/fetch_music.py

      - name: Render 3 videos
        env:
          LINK_HUB_URL: ${{ secrets.LINK_HUB_URL }}
        run: |
          mkdir -p out
          count=0
          tail -n +2 data/quotes.csv | while IFS=',' read -r id text author tags; do
            [ $count -ge 3 ] && break
            BG=$(ls assets/backgrounds/* | shuf -n1)
            MU=$(ls assets/music/*.mp3 | shuf -n1)
            OUT="out/short_${id}.mp4"
            bash scripts/render.sh "$text" "$author" "$BG" "$MU" "$OUT"
            python3 scripts/prepare_metadata.py "$text" "$author" "$tags" > "out/meta_${id}.txt"
            count=$((count+1))
          done

      - name: Upload to YouTube
        env:
          YT_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          YT_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          python3 - << 'PY'
import os, glob, time
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from google.auth.transport.requests import Request

creds = Credentials(None,
    refresh_token=os.environ['YT_REFRESH_TOKEN'],
    client_id=os.environ['YT_CLIENT_ID'],
    client_secret=os.environ['YT_CLIENT_SECRET'],
    token_uri='https://oauth2.googleapis.com/token')
creds.refresh(Request())
yt = build('youtube','v3',credentials=creds)

metas = sorted(glob.glob('out/meta_*.txt'))
videos = sorted(glob.glob('out/short_*.mp4'))
for meta, video in zip(metas, videos):
    with open(meta,'r',encoding='utf-8') as f:
        parts = f.read().split('-----')
    title = parts[0].strip()
    desc  = parts[1].strip() + "\n#shorts"
    tags  = [t.strip() for t in parts[2].split(',') if t.strip()]
    body = dict(
        snippet=dict(title=title, description=desc, tags=tags, categoryId='22'),
        status=dict(privacyStatus='public', selfDeclaredMadeForKids=False)
    )
    request = yt.videos().insert(part="snippet,status", body=body, media_body=video)
    resp = request.execute()
    print("Uploaded video id:", resp.get('id'))
    time.sleep(3)
PY
